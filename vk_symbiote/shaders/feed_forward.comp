#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 256) in;

// Input/output activation buffers
layout(binding = 0, std430) readonly buffer InputBuf { float input_data[]; };
layout(binding = 1, std430) writeonly buffer OutputBuf { float output_data[]; };

// Weight buffers
layout(binding = 2, std430) readonly buffer GateWeight { float gate_weight[]; };
layout(binding = 3, std430) readonly buffer UpWeight { float up_weight[]; };
layout(binding = 4, std430) readonly buffer DownWeight { float down_weight[]; };

layout(push_constant) uniform PC {
    uint32_t hidden_size;
    uint32_t intermediate_size;
    uint32_t seq_len;
} pc;

float silu(float x) { return x / (1.0 + exp(-x)); }

// Shared memory for gate/up projections per token
// Each thread handles one output dimension
// Shared memory holds intermediate results [intermediate_size]
shared float shared_gate[4096];  // Max intermediate size
shared float shared_up[4096];

void main() {
    uint32_t gid = gl_GlobalInvocationID.x;
    uint32_t token = gid / pc.hidden_size;
    uint32_t h = gid % pc.hidden_size;
    
    if (token >= pc.seq_len || h >= pc.hidden_size) return;
    
    // Compute gate and up projections once per token in parallel
    // This is done by all threads cooperatively
    for (uint32_t i = gl_LocalInvocationID.x; i < pc.intermediate_size; i += gl_WorkGroupSize.x) {
        float gate = 0.0;
        float up = 0.0;
        
        // Matrix multiplication: input [hidden] @ weight [hidden, intermediate]
        for (uint32_t j = 0; j < pc.hidden_size; ++j) {
            float input_val = input_data[token * pc.hidden_size + j];
            gate += input_val * gate_weight[i * pc.hidden_size + j];
            up += input_val * up_weight[i * pc.hidden_size + j];
        }
        
        shared_gate[i] = silu(gate);
        shared_up[i] = up;
    }
    
    barrier();
    
    // Now compute down projection for this thread's output dimension
    float output_val = 0.0;
    
    // Matrix multiplication: (gate * up) [intermediate] @ down_weight [intermediate, hidden]
    // Each thread computes one output dimension h
    for (uint32_t i = 0; i < pc.intermediate_size; ++i) {
        output_val += shared_gate[i] * shared_up[i] * down_weight[i * pc.hidden_size + h];
    }
    
    uint32_t base_idx = token * pc.hidden_size + h;
    output_data[base_idx] = output_val;
}
